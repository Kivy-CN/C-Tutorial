# C语言程序设计

# 1 程序设计语言的基础知识

## 1.1 什么是程序设计语言？

在没有大语言模型以前，计算机无法理解人类语言。
人类要控制计算机做出某些运算，就要用机器语言。
最开始的机器语言是纸片打孔形式的，
后来有了汇编语言，用助记符代替机器指令。
然后，又有了更高级的程序设计语言，提高了抽象层次。
高级语言比机器语言抽象层次更高，更接近人类语言，有C、C++、Java、Python等。

下面是一个简单的汇编程序，它将两个数相加并将结果存储在第一个数中：

```ASM
section .data
    // 定义变量num1，类型为双字，值为10
    num1 dd 10
    // 定义变量num2，类型为双字，值为20
    num2 dd 20

section .text
    // 定义全局变量_start
    global _start

_start:
    // 将num1的值赋给eax
    mov eax, [num1]
    // 将num2的值加到eax上
    add eax, [num2]
    // 将eax的值赋给num1
    mov [num1], eax
    // 将eax的值赋为1
    mov eax, 1
    // 将ebx的值赋为0
    xor ebx, ebx
    // 调用int 0x80，执行系统调用
    int 0x80
```

上面的汇编代码将 num1 和 num2 两个数相加，并将结果存储在 num1 中。这个程序使用 Linux 系统调用来退出程序.
该过程的 C 语言版本：

```C
#include <stdio.h>

int main() {
    int num1 = 10;
    int num2 = 20;
    num1 += num2;
    printf("%d\n", num1);
    return 0;
}
```

上面的C语言代码将 num1 和 num2 两个数相加，并将结果存储在 num1 中。这个程序使用 printf 函数来输出结果。
再改写成Python代码如下：

```Python
num1 = 10
num2 = 20
num1 += num2
print(num1)
```

抽象层次越来越高，代码复杂度越来越低，人类阅读理解和编写也都越来越简洁。

但为什么不直接学Python，还是要学一下C语言呢？

* Python语法简单易学，适合快速开发原型和小型项目；有很多强大的库和框架，可以快速实现各种功能。
* C语言可以直接访问计算机的硬件资源，可实现高效代码，用于系统编程、嵌入式系统和操作系统等领域。

各有各的好处，先都学着了解一下，后续根据需求自行深入探索。

## 1.2 程序开发的步骤

这部分的英语单词需要熟悉，可能以后要常常用到。

| 单词     | 含义 | 解释           |
| -------- | ---- | -------------- |
| Analysis | 分析 | 程序的用途     |
| Design   | 设计 | 如何来实现     |
| Edit     | 编辑 | 具体写代码     |
| Compile  | 编译 | 编译到目标文件 |
| Link     | 链接 | 生成可执行文件 |
| Run      | 运行 | 运行可执行文件 |
| Debug    | 调试 | 修改错误重来   |

Compile 和 Link 这两步骤是针对不同操作系统平台的，生成对应的目标文件和可执行文件。
其他步骤都是跨平台的。
也就是说，同样的一份 C 语言代码，可以在 Windows、Linux、MacOS 平台上编译运行。
代码是完全相同的情况下，不同操作系统上编译出来的目标文件、链接出来的可执行文件各自不同。

### 1.2.1 需求分析

需求分析是程序开发的第一步，也是最重要的一步。
需求分析的目的是得到软件开发的目标，并形成文档。
要写什么样的程序，要做啥事情。

### 1.2.2 设计

设计是程序开发的中间阶段，也是最重要的阶段。
设计是程序开发的关键，设计的好坏直接影响程序的性能和开发周期。
怎么去做到，如何来实现。

### 1.2.3 编码

编码是程序开发的最核心阶段，也是最耗时和最困难的一步。
编码阶段，需要程序员对程序进行编码，包括程序的编写和测试。
按照设计一步步编写代码，从人类语言转化为程序设计语言。

### 1.3.4 编译、链接、运行、调试

编译器读取源代码，编译出来目标文件，再由链接器链接成可执行文件。
可执行文件就能拿来运行，如果有错误就进行修改，这个过程教易出错，需要调试。

![](./images/1-coding-process.png)

## 1.3 程序运行的过程

程序运行有很多种方式。

### 按照运行方式：

* 编译型语言，是先翻译成机器语言，再由机器执行。C、C++，Swift，Go
* 解释型语言，是先翻译成机器语言，再由机器逐行解释执行。Python、JavaScript
* 混合型语言，将源代码转换为机器代码，然后在一个环境中执行机器代码。C#，Java，Scala，Kotlin

C语言是编译型语言。

## 1.4 C语言的特性

### 1.4.1 访问范围广

* 可访问物理内存的语言：C、C++、Rust
* 只可访问堆的语言：C#、JavaScript
* 只可访问栈的语言：Java、Python

堆和栈都是计算机内存的一部分。
堆的分配和释放需要由开发者手动完成。
栈的分配和释放是由编译器自动完成的。

能访问物理内存的语言，适合操作系统以及驱动程序的开发。
这些任务 Python 很难胜任。

### 1.4.2 运行速度

* 静态类型语言：变量的类型必须在编译时确定，先声明，后使用；
* 动态类型语言：变量的类型可以在运行时确定，随时用，可更改。

C语言是静态类型语言，速度快。
Python是动态类型语言，速度慢。

##### 思考题 1 真的是这样么？一直以来都是这样么？各种场景都会这样么？

### 1.4.3 跨平台性

C语言被当今几乎所有主流操作系统所支持；
C语言编写的程序基本可以运行在任何操作系统上。


## 1.5 环境搭建

工欲善其事必先利其器，先把开发环境构建起来吧。

### 1.5.1 操作系统选择


### 1.5.2 编译器选择


### 1.5.3 编辑器选择


### 1.5.4 集成开发环境


# 2 初步体验C语言

## 2.1 第一个程序

第一个程序，一般都是 Hello World。

```C
#include <stdio.h>
int main()
{
    /* 在终端中输出 Hello World */
    //Prints the string "Hello, World!" to the console
    printf("Hello, World! \n"); 
    return 0;
}
```

## 2.2 性能对比

C语言的性能一定比Python快么？

下是一个更复杂的例子，它将使用C语言和Python计算斐波那契数列的前1000个数字：

C语言代码：

```C
#include <stdio.h>
#include <time.h>

int main() {
    // 定义变量n，表示要输出多少个斐波那契数列
    int n = 100, i, t1 = 0, t2 = 1, nextTerm;
    // 输出提示信息
    printf("Fibonacci Series: ");

    // 记录开始时间
    clock_t start = clock();
    // 循环输出斐波那契数列
    for (i = 1; i <= n; ++i) {
        // 输出斐波那契数列的值
        printf("%d, ", t1);
        // 计算下一个斐波那契数列的值
        nextTerm = t1 + t2;
        // 更新t1和t2的值
        t1 = t2;
        t2 = nextTerm;
    }
    // 记录结束时间
    clock_t end = clock();

    // 计算程序运行的时间
    double time_spent = (double)(end - start) / CLOCKS_PER_SEC;
    // 输出程序运行的时间
    printf("\nTime taken: %f seconds\n", time_spent);

    return 0;
}
```

输出如下：

```Bash
Fibonacci Series: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887, 9227465, 14930352, 24157817, 39088169, 63245986, 102334155, 165580141, 267914296, 433494437, 701408733, 1134903170, 1836311903, -1323752223, 512559680, -811192543, -298632863, -1109825406, -1408458269, 1776683621, 368225352, 2144908973, -1781832971, 363076002, -1418756969, -1055680967, 1820529360, 764848393, -1709589543, -944741150, 1640636603, 695895453, -1958435240, -1262539787, 1073992269, -188547518, 885444751, 696897233, 1582341984, -2015728079, -433386095, 1845853122, 1412467027, -1036647147, 375819880, -660827267, -285007387, -945834654, -1230842041, 2118290601, 887448560, -1289228135, -401779575, -1691007710, -2092787285, 511172301, -1581614984, -1070442683, 1642909629, 572466946, -2079590721, -1507123775, 708252800, -798870975, -90618175, -889489150, 
Time taken: 0.004000 seconds
```

##### 思考题 2 为什么C语言版本的斐波那契数列从 2144908973 往后的突然变成负数了？

Python代码：

```Python
import time

# 定义变量n，赋值为100
n = 100
# 定义变量t1，t2，赋值为0，1
t1, t2 = 0, 1
# 打印字符串，end=" "表示打印空格
print("Fibonacci Series: ", end=" ")
# 记录开始时间
start = time.time()
# 循环n次，每次打印t1，t2，t1+t2赋值给t2
for i in range(n):
    print(t1, end=" ")
    nextTerm = t1 + t2
    t1 = t2
    t2 = nextTerm
# 记录结束时间
end = time.perf_counter()

# 计算时间差
time_spent = end - start
# 打印时间差，单位为秒
print("\nTime taken: ", time_spent, " seconds")
```

输出如下：

```Bash
Fibonacci Series:  0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711 28657 46368 75025 121393 196418 317811 514229 832040 1346269 2178309 3524578 5702887 9227465 14930352 24157817 39088169 63245986 102334155 165580141 267914296 433494437 701408733 1134903170 1836311903 2971215073 4807526976 7778742049 12586269025 20365011074 32951280099 53316291173 86267571272 139583862445 225851433717 365435296162 591286729879 956722026041 1548008755920 2504730781961 4052739537881 6557470319842 10610209857723 17167680177565 27777890035288 44945570212853 72723460248141 117669030460994 190392490709135 308061521170129 498454011879264 806515533049393 1304969544928657 2111485077978050 3416454622906707 5527939700884757 8944394323791464 14472334024676221 23416728348467685 37889062373143906 61305790721611591 99194853094755497 160500643816367088 259695496911122585 420196140727489673 679891637638612258 1100087778366101931 1779979416004714189 2880067194370816120 4660046610375530309 7540113804746346429 12200160415121876738 19740274219868223167 31940434634990099905 51680708854858323072 83621143489848422977 135301852344706746049 218922995834555169026 
Time taken:  0.00033409999741706997  seconds
```

很多教科书上都说，C语言快、Python慢。但是，随着Python的版本演进，有的时候Python未必比C慢。
具体的速度，不仅仅看编程语言本身，还要看使用的场景和代码编写方式等等。

## 2.3 尽信书不如无书

时代发展很快，技术更新很快，很多书籍出版出来的时候，内容就已经落伍了。
以前有的书上只说C语言可以写驱动和操作系统内核。
实际上现在已经有很多驱动和操作系统内核部分是使用RUST语言来写了。

不要迷信任何权威。
如果过了很多年，关于这门课你已经没有太多印象了，我希望你还至少能记得这一点。
代码是最公正的，拿来运行，直接出结果。

## 2.4 代码的注释和规范

机器看的部分，自然就是代码本体。
人看的部分，一般就是注释。
上面的C语言代码中，注释的形式是用 `//`,这是单行的注释。
多行的注释有的是下面这样子的：

```C
    /*多行的代码
    可以这样注释掉*/
```

实际上你根本不用费劲去记忆哪个是第一种方式，哪个是第二种方式。
在 VS Code 之类的编辑器里面，直接都用 `CTRL+/`之类的快捷键来添加注释了。
甚至有了CodeGeex之类的AI代码生成工具，只写代码主体，然后用AI代码生成工具可以自动生成注释。

但无论如何，你的代码都应该有注释。
要不然可能过了没多久，一天两天，甚至一两分钟之后，你都可能忘了代码里面有些什么东西。

代码的规范，主要是指代码的格式。
对C语言的代码，不同的开源组织、开发项目、开源社区，甚至不同的公司，都有不同的规范。
大家尽量先照着课程样例代码来尝试着修改。
等以后参与具体的开发的时候，再找对应的复杂的代码规范来遵守。
