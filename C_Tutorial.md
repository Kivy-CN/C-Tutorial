# C语言程序设计

# 1 程序设计语言的基础知识

## 1.1 什么是程序设计语言？

在没有大语言模型以前，计算机无法理解人类语言。
人类要控制计算机做出某些运算，就要用机器语言。
最开始的机器语言是纸片打孔形式的，
后来有了汇编语言，用助记符代替机器指令。
然后，又有了更高级的程序设计语言，提高了抽象层次。
高级语言比机器语言抽象层次更高，更接近人类语言，有C、C++、Java、Python等。

下面是一个简单的汇编程序，它将两个数相加并将结果存储在第一个数中：

```ASM
section .data
    // 定义变量num1，类型为双字，值为10
    num1 dd 10
    // 定义变量num2，类型为双字，值为20
    num2 dd 20

section .text
    // 定义全局变量_start
    global _start

_start:
    // 将num1的值赋给eax
    mov eax, [num1]
    // 将num2的值加到eax上
    add eax, [num2]
    // 将eax的值赋给num1
    mov [num1], eax
    // 将eax的值赋为1
    mov eax, 1
    // 将ebx的值赋为0
    xor ebx, ebx
    // 调用int 0x80，执行系统调用
    int 0x80
```

上面的汇编代码将 num1 和 num2 两个数相加，并将结果存储在 num1 中。这个程序使用 Linux 系统调用来退出程序.
该过程的 C 语言版本：

```C
#include <stdio.h>

int main() {
    int num1 = 10;
    int num2 = 20;
    num1 += num2;
    printf("%d\n", num1);
    return 0;
}
```

上面的C语言代码将 num1 和 num2 两个数相加，并将结果存储在 num1 中。这个程序使用 printf 函数来输出结果。
再改写成Python代码如下：

```Python
num1 = 10
num2 = 20
num1 += num2
print(num1)
```

抽象层次越来越高，代码复杂度越来越低，人类阅读理解和编写也都越来越简洁。

但为什么不直接学Python，还是要学一下C语言呢？

* Python语法简单易学，适合快速开发原型和小型项目；有很多强大的库和框架，可以快速实现各种功能。
* C语言可以直接访问计算机的硬件资源，可实现高效代码，用于系统编程、嵌入式系统和操作系统等领域。

各有各的好处，先都学着了解一下，后续根据需求自行深入探索。

## 1.2 程序开发的步骤

这部分的英语单词需要熟悉，可能以后要常常用到。

| 单词     | 含义 | 解释           |
| -------- | ---- | -------------- |
| Analysis | 分析 | 程序的用途     |
| Design   | 设计 | 如何来实现     |
| Edit     | 编辑 | 具体写代码     |
| Compile  | 编译 | 编译到目标文件 |
| Link     | 链接 | 生成可执行文件 |
| Run      | 运行 | 运行可执行文件 |
| Debug    | 调试 | 修改错误重来   |

Compile 和 Link 这两步骤是针对不同操作系统平台的，生成对应的目标文件和可执行文件。
其他步骤都是跨平台的。
也就是说，同样的一份 C 语言代码，可以在 Windows、Linux、MacOS 平台上编译运行。
代码是完全相同的情况下，不同操作系统上编译出来的目标文件、链接出来的可执行文件各自不同。

### 1.2.1 需求分析

需求分析是程序开发的第一步，也是最重要的一步。
需求分析的目的是得到软件开发的目标，并形成文档。
要写什么样的程序，要做啥事情。

### 1.2.2 设计

设计是程序开发的中间阶段，也是最重要的阶段。
设计是程序开发的关键，设计的好坏直接影响程序的性能和开发周期。
怎么去做到，如何来实现。

### 1.2.3 编码

编码是程序开发的最核心阶段，也是最耗时和最困难的一步。
编码阶段，需要程序员对程序进行编码，包括程序的编写和测试。
按照设计一步步编写代码，从人类语言转化为程序设计语言。

### 1.3.4 编译、链接、运行、调试

源代码（source code） → 预处理（preprocessor） → 编译器（compiler） → 汇编程序（assembler） → 目标代码（object code） → 链接器（Linker） → 可执行文件（executables）

编译器读取源代码，编译出来目标文件，再由链接器链接成可执行文件。
可执行文件就能拿来运行，如果有错误就进行修改，这个过程教易出错，需要调试。

![](./images/1-coding-process.png)

## 1.3 程序运行的过程

程序运行有很多种方式。

### 按照运行方式：

* 编译型语言，是先翻译成机器语言，再由机器执行。C、C++，Swift，Go
* 解释型语言，是先翻译成机器语言，再由机器逐行解释执行。Python、JavaScript
* 混合型语言，将源代码转换为机器代码，然后在一个环境中执行机器代码。C#，Java，Scala，Kotlin

C语言是编译型语言。

## 1.4 C语言的特性

### 1.4.1 访问范围广

* 可访问物理内存的语言：C、C++、Rust
* 只可访问堆的语言：C#、JavaScript
* 只可访问栈的语言：Java、Python

堆和栈都是计算机内存的一部分。
堆的分配和释放需要由开发者手动完成。
栈的分配和释放是由编译器自动完成的。

能访问物理内存的语言，适合操作系统以及驱动程序的开发。
这些任务 Python 很难胜任。

### 1.4.2 运行速度

* 静态类型语言：变量的类型必须在编译时确定，先声明，后使用；
* 动态类型语言：变量的类型可以在运行时确定，随时用，可更改。

C语言是静态类型语言，速度快。
Python是动态类型语言，速度慢。

##### 思考题 1 同样功能的代码，C语言实现的一定比Python的快么？一直都是这样么？考虑一下版本和不同场景。

### 1.4.3 跨平台性

C语言被当今几乎所有主流操作系统所支持；
C语言编写的程序基本可以运行在任何操作系统上。


## 1.5 环境搭建

工欲善其事必先利其器，先把开发环境构建起来吧。

### 1.5.1 硬件设备选择

C语言是运行在计算机上的程序语言，所以需要一台计算机。
低配置的笔记本电脑，或者台式机都可以。
当然了，要开发高性能需求的应用，或者想有比较好的体验，需要使用高性能的计算机。

C语言支持多种指令集的处理器，
* 32位处理器：x86、ARM、MIPS
* 64位处理器：x86_64、ARM64、MIPS64

32位处理器有什么劣势？
+ 32位架构下，最大寻址空间是4GB，这是怎么算出来的？2^32 = 32 Gb = 4GB
+ 当然，后来有了内存地址扩展（PAE，Physical Address Extension）。

1 Byte = 8 bit
1 KB = 1024 Byte
1 MB = 1024 KB
1 GB = 1024 MB
1 TB = 1024 GB
1 PB = 1024 TB
1 EB = 1024 PB
1 ZB = 1024 EB
1 YB = 1024 ZB

##### 思考题 2 32位处理器不考虑PAE的情况下能够访问的最大内存是多少？列出计算过程。

现代的比较新的笔记本电脑、台式机，以及手机，基本都是64位处理器了。
因此本课程推荐大家使用主流的64位处理器。

### 1.5.2 操作系统选择

C语言是运行在操作系统上的程序语言，所以需要选择一个操作系统。
常见的操作系统有哪些？
* 个人电脑（Personal Computer）：Windows、GNU/Linux、macOS
* 服务器（Server）：GNU/Linux、BSD
* 移动设备：iOS、Android
* 嵌入式系统（Embedded System）：GNU/Linux、RTOS

大家的电脑上安装的操作系统一般是：
* Windows：驱动相对完善，软件生态极度繁荣，适合日常场景。
* GNU/Linux：开源，免费，适合本地开发场景。
* macOS：平台独占，适合影音媒体创作场景。

大家之前可能也接触过 GNU/Linux 操作系统，而且以后的开发工作难免要以 GNU/Linux 操作系统作为开发环境。
因此本课程推荐大家使用 GNU/Linux 操作系统。

具体的发行版方面，推荐使用 Ubuntu 22.04.3 LTS，这个发行版的硬件驱动支持和软件生态都相对完善。

当然了，Windows 和 macOS 也可以用于咱们这门课，只是尽量多接触 GNU/Linux 的开发生态，对大家以后熟练上手有帮助。

### 1.5.3 编译器选择

C语言是编译型语言，需要编译成目标文件，然后再由链接器生成可执行文件，所以需要选择一个编译器（Compiler）。
编译器是C语言开发环境的核心组件，现在主流的 C 语言编译器包括：
* Visual C++：微软的编译器，最初集成于 Visual Studio 之中，现在也开始支持其他平台。
* Clang：Clang是LLVM（Low Level Virtual Machine 缩写）的编译器，最初为macOS设计，现在支持多平台。
* GNU GCC：GNU编译器集合，支持多种处理器架构，支持多种编程语言，支持多种操作系统。
* 其它：其它一些编译器，比如IAR、Keil、TinyCC等。

以前的很多教材和课程都推荐大家用 Visual C++，涉及到很多Visual Studio 的相关内容，比如如何新建工程等等，这些对于初学C语言来说过于琐碎。

本课程推荐大家使用 GCC 编译器。

GCC 是一个套件，实际上包含了编译器和链接器等全套工具了。
* 编译器负责将C语言源文件编译成目标文件（在Windows下扩展名通常位obj）；
* 链接器负责将目标文件链接成可执行文件（在Windows下扩展名通常为exe）。

### 1.5.4 GCC 的安装与使用

Windows 下可以通过[MinGW](https://www.mingw-w64.org/downloads/#w64devkit)来安装GCC，但实际上还有更方便的途径，后面讲集成开发环境再说。

macOS 下可以通过 包管理器 HomeBrew 安装 GCC，命令如下：
```Bash
user@macos:~$ brew install gcc
```

Linux 下安装 GCC 很简单方便，直接用包管理器安装即可。
Ubuntu 下可以通过 apt 命令安装 GCC，命令如下：
```Bash
user@linux:~$ sudo apt install build-essential 
```
安装完成后，在终端中输入 `gcc --version` 命令，如果看到类似下面的输出，就说明安装成功了：
```Bash
user@linux:~$ gcc --version
gcc (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0
Copyright (C) 2021 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.   
```

GCC 使用非常简便，就像下面这样：
```Bash
user@linux:~$ ls # list的意思，这是列表显示当前目录下的文件
hello.c
user@linux:~$ cat hello.c # cat是显示的意思，这是显示hello.c的内容
#include <stdio.h>
int main() 
{
    /* 在终端中输出 Hello World */
    //Prints the string "Hello, World!" to the console
    printf("Hello, World! \n");
    return 0;
}
user@linux:~$ gcc hello.c # gcc是编译的意思，这是将hello.c编译出来
user@linux:~$ ls # 再次列表显示，看到按照默认配置会生成的一个a.out文件
a.out  hello.c
user@linux:~$ ./a.out # ./是当前路径的意思，这里是执行a.out文件
Hello, World! # 终端显示Hello, World!代码执行成功
user@linux:~$ gcc hello.c -o hello # 这里是使用-o参数指定生成的可执行文件名
user@linux:~$ ls # 再次列表显示，看到生成了一个hello文件
a.out  hello  hello.c 
user@linux:~$ ./hello # 这里执行的是hello文件，终端显示
Hello, World! # 代码执行成功
```

### 1.5.4 编辑器选择

编辑器，直观来解释，就是咱们编辑源代码文件输入代码的工具。
编辑器有很多种，有的是操作系统自带的，还有的需要额外安装。
大家以前肯定都用过诸如记事本之类的软件吧？记事本就是一个编辑器。
开发领域常见的编辑器有以下这些：
* Vi/Vim 效率高强，无需鼠标，非常经典；
* Emacs 功能强大，扩展丰富，也非常经典；
* Nano 非常轻量级，支持多种操作系统；
* Sublime Text 跨平台，支持多种操作系统，功能强大，但收费；
* Atom 跨平台，支持多种操作系统，功能强大，开源免费；
* Visual Studio Code 跨平台，支持多种操作系统，功能强大，开源免费；
* Visual Studio Codium 跨平台，支持多种操作系统，功能强大，开源免费。

还有很多其他的编辑器，此处不一一赘述。
本课程推荐使用 Visual Studio Code 或者 Visual Studio Codium。

在一些低能耗场景，比如路由器操作系统 OpenWRT、树莓派操作系统 Raspbian 等，可能没有图形界面，只能使用命令行界面，此时推荐使用 Nano。


### 1.5.5 集成开发环境


# 2 初步体验C语言

## 2.1 第一个程序

第一个程序，一般都是 Hello World。

```C
#include <stdio.h>
int main()
{
    /* 在终端中输出 Hello World */
    //Prints the string "Hello, World!" to the console
    printf("Hello, World! \n"); 
    return 0;
}
```

## 2.2 性能对比

C语言的性能一定比Python快么？

下是一个更复杂的例子，它将使用C语言和Python计算斐波那契数列的前1000个数字：

C语言代码：

```C
#include <stdio.h>
#include <time.h>

int main() {
    // 定义变量n，表示要输出多少个斐波那契数列
    int n = 100, i, t1 = 0, t2 = 1, nextTerm;
    // 输出提示信息
    printf("Fibonacci Series: ");

    // 记录开始时间
    clock_t start = clock();
    // 循环输出斐波那契数列
    for (i = 1; i <= n; ++i) {
        // 输出斐波那契数列的值
        printf("%d, ", t1);
        // 计算下一个斐波那契数列的值
        nextTerm = t1 + t2;
        // 更新t1和t2的值
        t1 = t2;
        t2 = nextTerm;
    }
    // 记录结束时间
    clock_t end = clock();

    // 计算程序运行的时间
    double time_spent = (double)(end - start) / CLOCKS_PER_SEC;
    // 输出程序运行的时间
    printf("\nTime taken: %f seconds\n", time_spent);

    return 0;
}
```

输出如下：

```Bash
Fibonacci Series: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887, 9227465, 14930352, 24157817, 39088169, 63245986, 102334155, 165580141, 267914296, 433494437, 701408733, 1134903170, 1836311903, -1323752223, 512559680, -811192543, -298632863, -1109825406, -1408458269, 1776683621, 368225352, 2144908973, -1781832971, 363076002, -1418756969, -1055680967, 1820529360, 764848393, -1709589543, -944741150, 1640636603, 695895453, -1958435240, -1262539787, 1073992269, -188547518, 885444751, 696897233, 1582341984, -2015728079, -433386095, 1845853122, 1412467027, -1036647147, 375819880, -660827267, -285007387, -945834654, -1230842041, 2118290601, 887448560, -1289228135, -401779575, -1691007710, -2092787285, 511172301, -1581614984, -1070442683, 1642909629, 572466946, -2079590721, -1507123775, 708252800, -798870975, -90618175, -889489150, 
Time taken: 0.004000 seconds
```

##### 思考题 2 为什么C语言版本的斐波那契数列从 2144908973 往后的突然变成负数了？

Python代码：

```Python
import time

# 定义变量n，赋值为100
n = 100
# 定义变量t1，t2，赋值为0，1
t1, t2 = 0, 1
# 打印字符串，end=" "表示打印空格
print("Fibonacci Series: ", end=" ")
# 记录开始时间
start = time.time()
# 循环n次，每次打印t1，t2，t1+t2赋值给t2
for i in range(n):
    print(t1, end=" ")
    nextTerm = t1 + t2
    t1 = t2
    t2 = nextTerm
# 记录结束时间
end = time.perf_counter()

# 计算时间差
time_spent = end - start
# 打印时间差，单位为秒
print("\nTime taken: ", time_spent, " seconds")
```

输出如下：

```Bash
Fibonacci Series:  0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711 28657 46368 75025 121393 196418 317811 514229 832040 1346269 2178309 3524578 5702887 9227465 14930352 24157817 39088169 63245986 102334155 165580141 267914296 433494437 701408733 1134903170 1836311903 2971215073 4807526976 7778742049 12586269025 20365011074 32951280099 53316291173 86267571272 139583862445 225851433717 365435296162 591286729879 956722026041 1548008755920 2504730781961 4052739537881 6557470319842 10610209857723 17167680177565 27777890035288 44945570212853 72723460248141 117669030460994 190392490709135 308061521170129 498454011879264 806515533049393 1304969544928657 2111485077978050 3416454622906707 5527939700884757 8944394323791464 14472334024676221 23416728348467685 37889062373143906 61305790721611591 99194853094755497 160500643816367088 259695496911122585 420196140727489673 679891637638612258 1100087778366101931 1779979416004714189 2880067194370816120 4660046610375530309 7540113804746346429 12200160415121876738 19740274219868223167 31940434634990099905 51680708854858323072 83621143489848422977 135301852344706746049 218922995834555169026 
Time taken:  0.00033409999741706997  seconds
```

很多教科书上都说，C语言快、Python慢。但是，随着Python的版本演进，有的时候Python未必比C慢。
具体的速度，不仅仅看编程语言本身，还要看使用的场景和代码编写方式等等。

## 2.3 尽信书不如无书

时代发展很快，技术更新很快，很多书籍出版出来的时候，内容就已经落伍了。
以前有的书上只说C语言可以写驱动和操作系统内核。
实际上现在已经有很多驱动和操作系统内核部分是使用RUST语言来写了。

不要迷信任何权威。
如果过了很多年，关于这门课你已经没有太多印象了，我希望你还至少能记得这一点。
代码是最公正的，拿来运行，直接出结果。

## 2.4 代码的注释和规范

机器看的部分，自然就是代码本体。
人看的部分，一般就是注释。
上面的C语言代码中，注释的形式是用 `//`,这是单行的注释。
多行的注释有的是下面这样子的：

```C
    /*多行的代码
    可以这样注释掉*/
```

实际上你根本不用费劲去记忆哪个是第一种方式，哪个是第二种方式。
在 VS Code 之类的编辑器里面，直接都用 `CTRL+/`之类的快捷键来添加注释了。
甚至有了CodeGeex之类的AI代码生成工具，只写代码主体，然后用AI代码生成工具可以自动生成注释。

但无论如何，你的代码都应该有注释。
要不然可能过了没多久，一天两天，甚至一两分钟之后，你都可能忘了代码里面有些什么东西。

代码的规范，主要是指代码的格式。
对C语言的代码，不同的开源组织、开发项目、开源社区，甚至不同的公司，都有不同的规范。
大家尽量先照着课程样例代码来尝试着修改。
等以后参与具体的开发的时候，再找对应的复杂的代码规范来遵守。
